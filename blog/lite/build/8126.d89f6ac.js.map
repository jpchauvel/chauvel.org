{"version":3,"file":"8126.d89f6ac.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/apputils/lib/licenses.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/apputils/lib/pluginmanager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/apputils/lib/translation.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/apputils/lib/statedb.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/apputils/lib/workspaces.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/apputils/lib/workspace-router.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Licenses } from '@jupyterlab/apputils';\nimport { URLExt, PageConfig } from '@jupyterlab/coreutils';\n/**\n * The well-known name of the file. Can actually be configured by alternate\n * implementations, but the default is probably good enough for \"best-effort.\"\n */\nexport const THIRD_PARTY_LICENSES = 'third-party-licenses.json';\n/**\n * An empty bundle.\n */\nconst EMPTY_BUNDLE = Object.freeze({ packages: [] });\n/**\n * A JupyterLite implementation of the jupyterlab_server licenses route\n */\nexport class LiteLicensesClient extends Licenses.LicensesClient {\n    /**\n     * A GET handler for the licenses\n     */\n    async getBundles() {\n        return {\n            bundles: {\n                ...(await this._getFederated()),\n                [this.appName]: await this._getAppLicenses(),\n            },\n        };\n    }\n    /**\n     * Download the licenses in the requested format.\n     */\n    async download(options) {\n        const link = document.createElement('a');\n        link.href = await this._getDownloadLink(options);\n        const extension = options.format === 'markdown' ? 'md' : options.format;\n        link.download = `jupyterlite-licenses.${extension}`;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n    /**\n     * Get the app name (or default).\n     */\n    get appName() {\n        return PageConfig.getOption('appName') || 'JupyterLite';\n    }\n    /**\n     * Get the well-known URL of the app licenses.\n     */\n    get appLicensesUrl() {\n        return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);\n    }\n    /**\n     * Get the lab extension base url.\n     */\n    get labExtensionsUrl() {\n        return PageConfig.getOption('fullLabextensionsUrl');\n    }\n    /**\n     * Get the download link for the requested format\n     */\n    async _getDownloadLink(options) {\n        const bundles = await this.getBundles();\n        let formattedData;\n        let mime;\n        // Format the data based on the requested format\n        switch (options.format) {\n            case 'json':\n                formattedData = JSON.stringify(bundles, null, 2);\n                mime = 'application/json';\n                break;\n            case 'markdown':\n                formattedData = this._formatAsMarkdown(bundles);\n                mime = 'text/markdown';\n                break;\n            case 'csv':\n                formattedData = this._formatAsCSV(bundles);\n                mime = 'text/csv';\n                break;\n            default:\n                // Fallback to JSON\n                formattedData = JSON.stringify(bundles, null, 2);\n                mime = 'application/json';\n        }\n        // Create a blob with the appropriate MIME type\n        const blob = new Blob([formattedData], { type: mime });\n        // Generate a URL for the blob\n        return URL.createObjectURL(blob);\n    }\n    /**\n     * Format license data as Markdown\n     */\n    _formatAsMarkdown(data) {\n        let md = '# Third-Party Licenses\\n\\n';\n        // Process each bundle\n        for (const [bundleName, bundle] of Object.entries(data.bundles)) {\n            md += `## ${bundleName}\\n\\n`;\n            // Process packages in the bundle\n            for (const pkg of bundle.packages) {\n                md += `### ${pkg.name}${pkg.versionInfo ? ` ${pkg.versionInfo}` : ''}\\n\\n`;\n                if (pkg.licenseId) {\n                    md += `**License ID:** ${pkg.licenseId}\\n\\n`;\n                }\n                if (pkg.extractedText) {\n                    md += `\\`\\`\\`\\n${pkg.extractedText}\\n\\`\\`\\`\\n\\n`;\n                }\n            }\n        }\n        return md;\n    }\n    /**\n     * Format license data as CSV\n     */\n    _formatAsCSV(data) {\n        // CSV header\n        const headers = ['Bundle', 'Package', 'Version', 'License ID', 'License Text'];\n        let csv = `${headers.join(',')}\\n`;\n        // Process each bundle and package\n        for (const [bundleName, bundle] of Object.entries(data.bundles)) {\n            for (const pkg of bundle.packages) {\n                const row = [\n                    this._escapeCSVField(bundleName),\n                    this._escapeCSVField(pkg.name),\n                    this._escapeCSVField(pkg.versionInfo || ''),\n                    this._escapeCSVField(pkg.licenseId || ''),\n                    this._escapeCSVField(pkg.extractedText || ''),\n                ];\n                csv += `${row.join(',')}\\n`;\n            }\n        }\n        return csv;\n    }\n    /**\n     * Escape a field for CSV output\n     */\n    _escapeCSVField(field) {\n        // If the field contains commas, quotes, or newlines, wrap it in quotes and escape any quotes\n        if (field && (field.includes(',') || field.includes('\"') || field.includes('\\n'))) {\n            return `\"${field.replace(/\"/g, '\"\"')}\"`;\n        }\n        return field;\n    }\n    /**\n     * Resolve the licenses for the app distribution itself, or the empty bundle.\n     */\n    async _getAppLicenses() {\n        let bundle = EMPTY_BUNDLE;\n        try {\n            const response = await fetch(this.appLicensesUrl);\n            bundle = response.json();\n        }\n        catch (err) {\n            console.warn('Could not resolve licenses for', this.appName);\n        }\n        return bundle;\n    }\n    /**\n     * Resolve the licenses for all federated extensions.\n     */\n    async _getFederated() {\n        const bundles = {};\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return bundles;\n        }\n        const promises = [];\n        for (const ext of federated) {\n            promises.push(this._getOneFederated(ext, bundles));\n        }\n        try {\n            await Promise.all(promises);\n        }\n        catch (err) {\n            console.warn('Error resolving licenses', err);\n        }\n        return bundles;\n    }\n    /**\n     * Update the bundles with the extension's licenses, or the empty bundle.\n     */\n    async _getOneFederated(ext, bundles) {\n        try {\n            const url = URLExt.join(this.labExtensionsUrl, ext.name, 'static', THIRD_PARTY_LICENSES);\n            const response = await fetch(url);\n            bundles[ext.name] = await response.json();\n        }\n        catch {\n            console.warn('Could not resolve licenses for', ext);\n            bundles[ext.name] = EMPTY_BUNDLE;\n        }\n    }\n}\n//# sourceMappingURL=licenses.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PluginListModel } from '@jupyterlab/pluginmanager';\n/**\n * Custom PluginModel for use in JupyterLite\n */\nexport class LitePluginListModel extends PluginListModel {\n    /**\n     * Create a new PluginListModel.\n     */\n    constructor(options) {\n        super(options);\n        this._availablePlugins = options.pluginData.availablePlugins.map((plugin) => {\n            let tokenLabel = plugin.provides ? plugin.provides.name.split(':')[1] : undefined;\n            if (plugin.provides && !tokenLabel) {\n                tokenLabel = plugin.provides.name;\n            }\n            return {\n                ...plugin,\n                tokenLabel,\n                // keep all plugins locked and enabled for now until there is\n                // a way to enable/disable plugins in JupyterLite\n                locked: true,\n                enabled: true,\n            };\n        });\n    }\n    get available() {\n        return this._availablePlugins;\n    }\n    async refresh() {\n        // no-op\n    }\n    async enable(entry) {\n        // no-op\n    }\n    async disable(entry) {\n        // no-op\n    }\n}\n//# sourceMappingURL=pluginmanager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * A fake locale to retrieve all the language packs.\n */\nconst ALL = 'all';\n/**\n * A class to fetch translation bundles.\n */\nexport class LiteTranslatorConnector extends DataConnector {\n    constructor() {\n        super(...arguments);\n        this._prevLocale = '';\n    }\n    async fetch(opts) {\n        var _a;\n        const language = (_a = opts === null || opts === void 0 ? void 0 : opts.language) !== null && _a !== void 0 ? _a : '';\n        // normalize the requested locale\n        let locale = language;\n        if (language === 'default') {\n            locale = 'en';\n        }\n        else if (language === '') {\n            locale = ALL;\n        }\n        const apiURL = URLExt.join(PageConfig.getBaseUrl(), `api/translations/${locale}.json`);\n        try {\n            const response = await fetch(apiURL);\n            const json = JSON.parse(await response.text());\n            if (this._prevLocale !== ALL && locale === ALL) {\n                // TODO: fix this logic upstream?\n                // the upstream translation plugin relies on the comparison between\n                // the display name and the native name to enable or disable the commands:\n                // https://github.com/jupyterlab/jupyterlab/blob/befa831ffef36321b87f352a48fbe2439df6c872/packages/translation-extension/src/index.ts#L117\n                const prev = this._prevLocale;\n                json.data[prev].displayName = json.data[prev].nativeName;\n                if (prev !== 'en') {\n                    json.data['en'].displayName = `${json.data['en'].nativeName} (default)`;\n                }\n            }\n            this._prevLocale = locale;\n            return json;\n        }\n        catch (e) {\n            if (locale) {\n                return {\n                    data: {},\n                    message: `Language pack '${locale}' not installed!`,\n                };\n            }\n            return {\n                data: {\n                    en: { displayName: 'English', nativeName: 'English' },\n                },\n                message: '',\n            };\n        }\n    }\n}\n//# sourceMappingURL=translation.js.map","import { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * A StateDB data connector backed by IndexedDB\n */\nexport class IndexedDBDataConnector {\n    /**\n     * Construct a new IndexedDBDataConnector.\n     *\n     * @param options - The options for the data connector.\n     */\n    constructor(options) {\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n        this.initialize().catch(console.warn);\n    }\n    /**\n     * Initialize the data connector.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this._ready.promise.then(() => this._storage);\n    }\n    /**\n     * Initialize storage instance\n     */\n    async initStorage() {\n        this._storage = this.createStorage();\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for StateDB',\n            storeName: 'statedb',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Fetch a value from the data connector.\n     *\n     * @param id - The identifier of the value to fetch.\n     *\n     * @returns A promise that resolves with the fetched value.\n     */\n    async fetch(id) {\n        const result = (await (await this.storage).getItem(id));\n        if (!result) {\n            throw new Error(`Failed to fetch id ${id} from StateDB`);\n        }\n        return result;\n    }\n    /**\n     * List all values in a namespace.\n     *\n     * @param namespace - The namespace to list values from. Defaults to ''.\n     *\n     * @returns A promise that resolves with the list of IDs and values.\n     */\n    async list(namespace = '') {\n        const storage = await this.storage;\n        const items = {};\n        for (const key of await storage.keys()) {\n            // Casting to string here, we know for sure the item is there\n            items[key] = (await storage.getItem(key));\n        }\n        const result = Object.keys(items).reduce((acc, val) => {\n            if (namespace === '' ? true : namespace === val.split(':')[0]) {\n                acc.ids.push(val);\n                acc.values.push(items[val]);\n            }\n            return acc;\n        }, { ids: [], values: [] });\n        return result;\n    }\n    /**\n     * Remove a value from the data connector.\n     *\n     * @param id - The identifier of the value to remove.\n     *\n     * @returns A promise that resolves when the value is removed.\n     */\n    async remove(id) {\n        await (await this.storage).removeItem(id);\n    }\n    /**\n     * Save a value to the data connector.\n     *\n     * @param id - The identifier of the value to save.\n     * @param value - The value to save.\n     *\n     * @returns A promise that resolves when the value is saved.\n     */\n    async save(id, value) {\n        await (await this.storage).setItem(id, value);\n    }\n}\n//# sourceMappingURL=statedb.js.map","import { ServerConnection } from '@jupyterlab/services';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { IndexedDBDataConnector } from './statedb';\n/**\n * A workspace manager for workspaces stored in the browser and on the server.\n */\nexport class LiteWorkspaceManager extends IndexedDBDataConnector {\n    /**\n     * Construct a new LiteWorkspaceManager.\n     *\n     * @param options - The options for the workspace manager.\n     */\n    constructor(options) {\n        super({ ...options });\n        this._workspacesApiUrl = PageConfig.getOption('workspacesApiUrl') ||\n            URLExt.join(PageConfig.getBaseUrl(), 'api/workspaces');\n        this.serverSettings = options.settings || ServerConnection.makeSettings();\n    }\n    /**\n     * Fetch a workspace by id.\n     *\n     * @param id - The workspace id\n     * @returns A promise that resolves with the workspace\n     */\n    async fetch(id) {\n        // First try to get from local storage\n        try {\n            const localWorkspace = await super.fetch(id);\n            if (localWorkspace) {\n                return localWorkspace;\n            }\n        }\n        catch (error) {\n            console.warn('Failed to fetch workspace from local storage:', error);\n        }\n        // Fall back to server\n        try {\n            const serverWorkspaces = await this._getServerWorkspaces();\n            if (serverWorkspaces[id]) {\n                return serverWorkspaces[id];\n            }\n        }\n        catch (error) {\n            console.warn('Failed to fetch workspace from server:', error);\n        }\n        // If neither local nor server has the workspace, throw an error\n        throw new Error(`Workspace with id '${id}' not found`);\n    }\n    /**\n     * List all workspaces.\n     *\n     * @returns A promise that resolves with all workspace ids\n     */\n    async list() {\n        var _a;\n        let serverWorkspaces = {};\n        // Try to get server workspaces\n        try {\n            serverWorkspaces = await this._getServerWorkspaces();\n        }\n        catch (error) {\n            console.warn('Failed to fetch workspaces from server:', error);\n        }\n        // Get local workspaces\n        const localResult = await super.list();\n        // Merge server and local workspaces, with local taking precedence for same IDs\n        const allWorkspaces = { ...serverWorkspaces };\n        for (const localWorkspace of localResult.values) {\n            if ((_a = localWorkspace.metadata) === null || _a === void 0 ? void 0 : _a.id) {\n                allWorkspaces[localWorkspace.metadata.id] = localWorkspace;\n            }\n        }\n        const ids = Object.keys(allWorkspaces);\n        const values = Object.values(allWorkspaces);\n        return { ids, values };\n    }\n    /**\n     * Clear all workspace data\n     *\n     * @returns A promise which resolves when the workspace data is cleared\n     */\n    async clear() {\n        await (await this.storage).clear();\n    }\n    /**\n     * Fetch all workspaces from the server\n     *\n     * @returns A promise that resolves with server workspaces\n     */\n    async _getServerWorkspaces() {\n        const workspacesUrl = URLExt.join(this._workspacesApiUrl, 'all.json');\n        const response = await fetch(workspacesUrl);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch workspaces: ${response.status} ${response.statusText}`);\n        }\n        return await response.json();\n    }\n}\n//# sourceMappingURL=workspaces.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * A token to advertise the workspace router is installed\n */\nexport const IWorkspaceRouter = new Token('@jupyterlite/apputils:IWorkspaceRouter');\n//# sourceMappingURL=workspace-router.js.map"],"names":["THIRD_PARTY_LICENSES","EMPTY_BUNDLE","Object","freeze","packages","LiteLicensesClient","Licenses","LicensesClient","getBundles","bundles","this","_getFederated","appName","_getAppLicenses","download","options","link","document","createElement","href","_getDownloadLink","extension","format","body","appendChild","click","removeChild","PageConfig","getOption","appLicensesUrl","URLExt","join","getBaseUrl","labExtensionsUrl","formattedData","mime","JSON","stringify","_formatAsMarkdown","_formatAsCSV","blob","Blob","type","URL","createObjectURL","data","md","bundleName","bundle","entries","pkg","name","versionInfo","licenseId","extractedText","csv","_escapeCSVField","field","includes","replace","fetch","json","err","console","warn","federated","parse","promises","ext","push","_getOneFederated","Promise","all","url","response","LitePluginListModel","PluginListModel","constructor","super","_availablePlugins","pluginData","availablePlugins","map","plugin","tokenLabel","provides","split","undefined","locked","enabled","available","refresh","enable","entry","disable","ALL","LiteTranslatorConnector","DataConnector","arguments","_prevLocale","opts","_a","language","locale","apiURL","text","prev","displayName","nativeName","e","message","en","DEFAULT_STORAGE_NAME","IndexedDBDataConnector","_storageName","_storageDrivers","_localforage","localforage","storageName","storageDrivers","_ready","PromiseDelegate","initialize","catch","initStorage","resolve","storage","promise","then","_storage","createStorage","defaultStorageOptions","driver","length","version","createInstance","description","storeName","id","result","getItem","Error","list","namespace","items","key","keys","reduce","acc","val","ids","values","remove","removeItem","save","value","setItem","LiteWorkspaceManager","_workspacesApiUrl","serverSettings","settings","ServerConnection","makeSettings","localWorkspace","error","serverWorkspaces","_getServerWorkspaces","localResult","allWorkspaces","metadata","clear","workspacesUrl","ok","status","statusText","IWorkspaceRouter","Token"],"sourceRoot":""}